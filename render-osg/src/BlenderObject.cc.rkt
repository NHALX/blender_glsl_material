#lang at-exp s-exp "../../misc/c-pre.rkt"

(export
 (begin 
  (import "BlenderMaterial"))

 @begin/text{
  @BlenderMaterial:header-source

  //////////////////////////////////////////////////
  // ╻ ╻
  // ┣━┫
  // ╹ ╹
  ///////// auto-generated by: @|__FILE__| /////////
  extern scheme _scheme;


  class BlenderObject : public osg::Group //, public osg::NodeCallback
  {
  protected:
      ~BlenderObject()
      {
          
        // TODO: free other stuff
      }
    
  public:
      BlenderObject(osg::ref_ptr<BlenderMaterial>, osg::ref_ptr<osg::Node>);
      
      osg::ref_ptr<osg::Program> _program;
	    
      static void *bind_attributes(void * const ctx,
                                   osg::Geode &geode,
                                   osg::Geometry* g);
      
      void bind_uniforms(osgUtil::CullVisitor* cv);	
      virtual void traverse(osg::NodeVisitor &nv);
      
      void set_m(const char *name, osg::Matrix m) 
      {
          getStateSet()->getOrCreateUniform(std::string(name),
                                            osg::Uniform::FLOAT_MAT4)->set(m);
      }
      
      void set_m(const char *name, osg::Matrix3 m) 
      {
          getStateSet()->getOrCreateUniform(std::string(name),
                                            osg::Uniform::FLOAT_MAT3)->set(m);
      }
      
  };

  
  struct bind_target {
      osg::Program  *program;
      BlenderObject *object;
      osg::Geometry *geometry;
  };

})


(source
  (begin
   (import "Matrix")
   (import* ".."))
        
  @begin/text{
  
  //////////////////////////////////////////////////
  // ┏━╸
  // ┃    
  // ┗━╸
  ///////// auto-generated by: @|__FILE__| /////////

  #include "OpenSceneGraph.hh"
  @Matrix:header-source
  #include "generated/scheme.h"
  @..:header-source
  #include "Traversal.hh"
  #include <stdexcept>


  BlenderObject::BlenderObject(
      osg::ref_ptr<BlenderMaterial> material, 
      osg::ref_ptr<osg::Node> node)
  {
      //getOrCreateStateSet();
      setName("BlenderObject");
      _program = material->getProgram();
      addChild(node);
      FoldGeodeGeometry fold = FoldGeodeGeometry(bind_attributes, this);
      node->accept(fold);
  }



  void
  BlenderObject::traverse(osg::NodeVisitor &nv)
  {
      //osgUtil::CullVisitor* cv = dynamic_cast<osgUtil::CullVisitor*>(&nv);

      //UNCOMMENT: if (cv && cv->getTraversalMask() == -1) // TODO: whats the correct mask?
          //    bind_uniforms(cv);
      /* UNCOMMENT:
  #ifdef UNIFORM_INPUT_MATRIX
      osg::Matrix model_view_inv;
      osg::Matrix model_view;

      model_view.orthoNormalize(*(cv->getModelViewMatrix()));
      model_view_inv.invert(model_view);

      set_m("my_ModelViewMatrix", model_view);
      set_m("my_ModelViewMatrixInverse", model_view_inv);
      set_m("my_NormalMatrix", normal_matrix(model_view_inv));
  #else
      osg::Matrix model_view;
      model_view.orthoNormalize(*(cv->getModelViewMatrix()));
      cv->getState()->applyModelViewMatrix(model_view);
  #endif
      */

      //_node->accept(nv); 
      osg::Group::traverse(nv);
  }


  void
  BlenderObject::bind_uniforms(osgUtil::CullVisitor* cv)
  {    

  }

  void *
  BlenderObject::bind_attributes(void * const ctx, osg::Geode &geode, osg::Geometry* g)
  {                
      BlenderObject *self = (BlenderObject*) ctx;
      geode.setNodeMask(CastsShadowTraversalMask|ReceivesShadowTraversalMask);
      bind_target target = {self->_program,self,g};
      //const real * const mark = vs_mark(_scheme.vs);
      ss_call1p(_scheme, "bind-attributes", &target);
      //vs_reset_to(_scheme.vs, mark);
      return ctx;
  }
 
 })
