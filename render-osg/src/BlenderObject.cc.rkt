#lang at-exp s-exp "../../misc/c-pre.rkt"

(export
 (begin (import "Shadow"))
 @begin/text{
  @Shadow:header-source
  //////////////////////////////////////////////////
  // ╻ ╻
  // ┣━┫
  // ╹ ╹
  ///////// auto-generated by: @|__FILE__| /////////
  extern scheme _scheme;
  extern bool loadShaderSource(osg::Shader* obj, const std::string& fileName );

  struct PreloadEnv
  {
      ShadowGroup *sg;
  };

  class BlenderMaterial : public osg::Group //, public osg::NodeCallback
  {
  protected:
      ~BlenderMaterial()
      {
          
          // TODO: free other stuff
      }
	
      osg::ref_ptr<osg::Program> _program;
      osg::ref_ptr<osg::Shader>  _vert;
      osg::ref_ptr<osg::Shader>  _frag;
	
  public:
      BlenderMaterial(const char *file_name);
	
      void         bind_uniforms(osgUtil::CullVisitor* cv);
      virtual void traverse(osg::NodeVisitor &nv);
	
      osg::ref_ptr<osg::Program> getProgram()
      {
          return _program;
      }

      void preload_samplers(PreloadEnv *);
  };



  class BlenderObject : public osg::Node //, public osg::NodeCallback
  {
  protected:
      ~BlenderObject()
      {
          
        // TODO: free other stuff
      }
    
  public:
      BlenderObject(osg::ref_ptr<BlenderMaterial>, osg::ref_ptr<osg::Node>);
      
      osg::ref_ptr<osg::Node>    _node;
      osg::ref_ptr<osg::Program> _program;
	    
      static void *bind_attributes(void * const ctx,
                                   osg::Geode &geode,
                                   osg::Geometry* g);
      
      void bind_uniforms(osgUtil::CullVisitor* cv);	
      virtual void traverse(osg::NodeVisitor &nv);
      
      void set_m(const char *name, osg::Matrix m) 
      {
          getStateSet()->getOrCreateUniform(std::string(name),
                                            osg::Uniform::FLOAT_MAT4)->set(m);
      }
      
      void set_m(const char *name, osg::Matrix3 m) 
      {
          getStateSet()->getOrCreateUniform(std::string(name),
                                            osg::Uniform::FLOAT_MAT3)->set(m);
      }
      
  };

  
  struct bind_target {
      osg::Program  *program;
      BlenderObject *object;
      osg::Geometry *geometry;
  };

})


(source
  (begin
   (import "Matrix")
   (import* ".."))
        
  @begin/text{
  
  //////////////////////////////////////////////////
  // ┏━╸
  // ┃    
  // ┗━╸
  ///////// auto-generated by: @|__FILE__| /////////

  #include "OpenSceneGraph.hh"
  @Matrix:header-source
  #include "generated/scheme.h"
  @..:header-source
  #include "Traversal.hh"
  #include <stdexcept>

  //static const matrix scheme_matrix(osg::Matrixd &m);

  BlenderMaterial::BlenderMaterial(const char *filebase)
  {
      #define SUFFIX_LEN     6
      #define SUFFIX_VERT    ".vert"
      #define SUFFIX_FRAG    ".frag"
      #define SUFFIX_UNIFORM ".scm\0"

      size_t len = SUFFIX_LEN + strlen(filebase);
      char buf[len];
      memcpy(buf, filebase, len - SUFFIX_LEN);

      _program = new osg::Program;
      _vert    = new osg::Shader(osg::Shader::VERTEX);
      _frag    = new osg::Shader(osg::Shader::FRAGMENT);

      memcpy(&buf[len - SUFFIX_LEN], SUFFIX_VERT, SUFFIX_LEN);
      if (!loadShaderSource(_vert, buf))
          std::runtime_error("BlenderMaterial.LoadFile: Vertex Shader");

      memcpy(&buf[len - SUFFIX_LEN], SUFFIX_FRAG, SUFFIX_LEN);
      if (!loadShaderSource(_frag, buf))
          std::runtime_error("BlenderMaterial.LoadFile: Fragment Shader");

      memcpy(&buf[len - SUFFIX_LEN], SUFFIX_UNIFORM, SUFFIX_LEN);
      ss_load(_scheme, buf); // TODO: error check

      _program->addShader(_frag);
      _program->addShader(_vert);

      getOrCreateStateSet()->setAttributeAndModes(_program,
                                                  osg::StateAttribute::ON);
  }


  void
  BlenderMaterial::traverse(osg::NodeVisitor &nv)
  {
      osgUtil::CullVisitor* cv = dynamic_cast<osgUtil::CullVisitor*>(&nv);

      if (cv && cv->getTraversalMask() == -1) // TODO: whats the correct mask?
          bind_uniforms(cv);

      osg::Group::traverse(nv); 
  }


  void
  BlenderMaterial::preload_samplers(PreloadEnv *sg)
  {
      //const real * const mark = vs_mark(_scheme.vs);
      ss_call1p(_scheme, "preload", sg);
      //vs_reset_to(_scheme.vs, mark);
  }


  void
  BlenderMaterial::bind_uniforms(osgUtil::CullVisitor* cv)
  {        
  #ifdef UNIFORM_INPUT_MATRIX
      const osg::Matrix& projection = *(cv->getProjectionMatrix());
      osg::Matrix projection_inv;
      projection_inv.invert(projection);

      set_m("my_ProjectionMatrix", projection);
      set_m("my_ProjectionMatrixInverse", projection_inv);
  #endif       

      osg::Matrix *view = new osg::Matrix;
      osg::Matrix *view_inv = new osg::Matrix;

      view->orthoNormalize(sync_matrix(
                            *(cv->getRenderStage()->getInitialViewMatrix())));

      // Warning: Do not double transpose 'view' by accident
      view_inv->invert(*view); 

      ss_set_m44_t(_scheme, "<world=>camera>", view);
      ss_set_m44_t(_scheme, "<camera=>world>", view_inv);

      ss_call1p(_scheme, "bind-samplers", this->getStateSet());
      ss_call1p(_scheme, "bind-uniforms", this->getStateSet());
  }


  ///////////////////////////


  BlenderObject::BlenderObject(osg::ref_ptr<BlenderMaterial> material, osg::ref_ptr<osg::Node> node)
  {
      //getOrCreateStateSet();

      _program = material->getProgram();
      _node    = node;
      FoldGeodeGeometry fold = FoldGeodeGeometry(bind_attributes, this);
      _node->accept(fold);
  }



  void
  BlenderObject::traverse(osg::NodeVisitor &nv)
  {
      osgUtil::CullVisitor* cv = dynamic_cast<osgUtil::CullVisitor*>(&nv);

      //UNCOMMENT: if (cv && cv->getTraversalMask() == -1) // TODO: whats the correct mask?
          //    bind_uniforms(cv);
      /* UNCOMMENT:
  #ifdef UNIFORM_INPUT_MATRIX
      osg::Matrix model_view_inv;
      osg::Matrix model_view;

      model_view.orthoNormalize(*(cv->getModelViewMatrix()));
      model_view_inv.invert(model_view);

      set_m("my_ModelViewMatrix", model_view);
      set_m("my_ModelViewMatrixInverse", model_view_inv);
      set_m("my_NormalMatrix", normal_matrix(model_view_inv));
  #else
      osg::Matrix model_view;
      model_view.orthoNormalize(*(cv->getModelViewMatrix()));
      cv->getState()->applyModelViewMatrix(model_view);
  #endif
      */

      _node->accept(nv); 
  }


  void
  BlenderObject::bind_uniforms(osgUtil::CullVisitor* cv)
  {    

  }

  void *
  BlenderObject::bind_attributes(void * const ctx, osg::Geode &geode, osg::Geometry* g)
  {                
      BlenderObject *self = (BlenderObject*) ctx;
      geode.setNodeMask(CastsShadowTraversalMask|ReceivesShadowTraversalMask);
      bind_target target = {self->_program,self,g};
      //const real * const mark = vs_mark(_scheme.vs);
      ss_call1p(_scheme, "bind-attributes", &target);
      //vs_reset_to(_scheme.vs, mark);
      return ctx;
  }
 
 })
