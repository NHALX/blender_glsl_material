#lang at-exp s-exp "../../misc/c-pre.rkt"
(require "language-ext.rkt")

(export (void) @begin/text{
  //////////////////////////////////////////////////
  // ╻ ╻
  // ┣━┫
  // ╹ ╹
  ///////// auto-generated by: @|__FILE__| /////////
 })

(source (begin
         (import "Matrix")
         (import "BlenderMaterial")
         (import "BlenderObject")
         (import "BlenderRenderState")
         (import "BindUniform")
         (import* ".."))
 @begin/text{
  
  //////////////////////////////////////////////////
  // ┏━╸
  // ┃    
  // ┗━╸
  ///////// auto-generated by: @|__FILE__| /////////
  
  #include "OpenSceneGraph.hh"
  @Matrix:header-source
  #include "generated/scheme.h"
  #include "generated/linear-algebra.h"
  @BlenderObject:header-source
  @BlenderRenderState:header-source
  #include <cstdarg>


  bool loadShaderSource(osg::Shader* obj, const std::string& fileName )
  {
      std::string fqFileName = osgDB::findDataFile(fileName);
      if( fqFileName.length() == 0 )
      {
          std::cout << "File \"" << fileName << "\" not found." << std::endl;
          return false;
      }
      bool success = obj->loadShaderSourceFromFile( fqFileName.c_str());
      if ( !success  )
      {
          std::cout << "Couldn't load file: " << fileName << std::endl;
          return false;
      }
      else
      {
          return true;
      }
  }

osg::Geode* createAxis()
{
    osg::Geode*     geode    = new osg::Geode();
    osg::Geometry*  geometry = new osg::Geometry();
    osg::Vec3Array* vertices = new osg::Vec3Array();
    osg::Vec4Array* colors   = new osg::Vec4Array();

    vertices->push_back(osg::Vec3(0.0f, 0.0f, 0.0f));
    vertices->push_back(osg::Vec3(10.0f, 0.0f, 0.0f));
    vertices->push_back(osg::Vec3(0.0f, 0.0f, 0.0f));
    vertices->push_back(osg::Vec3(0.0f, 10.0f, 0.0f));
    vertices->push_back(osg::Vec3(0.0f, 0.0f, 0.0f));
    vertices->push_back(osg::Vec3(0.0f, 0.0f, 10.0f));

    colors->push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f));
    colors->push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f));
    colors->push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f));
    colors->push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f));
    colors->push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f));
    colors->push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f));

    geometry->setVertexArray(vertices);
    geometry->setColorArray(colors, osg::Array::BIND_PER_VERTEX);
    geometry->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::LINES, 0, 6));
    geometry->getOrCreateStateSet()->setMode(GL_LIGHTING, false);

    geode->addDrawable(geometry);
    geode->setName("Axis");
    return geode;
}


  class Core {
  public:
      Core(){
          //root   = new osg::Group();
          viewer = new osgViewer::Viewer;
      }
      /*
      osg::ref_ptr<osg::Group>                  root;
      osg::ref_ptr<osg::Group>                  scene;*/
      osg::ref_ptr<osgViewer::Viewer>           viewer;
      osg::ref_ptr<osgGA::TrackballManipulator> manip;


      void db_init();
      void manipulator_init();
      void camera_init();
      void mainloop();

      osg::Matrixd perspective,view_matrix,view_matrix_inv,perspective_inv;
      osg::Matrix3 normal_matrix;
  };

  void Core::db_init()
  {
      osgDB::FilePathList pathList = osgDB::getDataFilePathList();
      pathList.push_back("/home/nha/data/osg/OpenSceneGraph-Data-3.0.0/");
      pathList.push_back(
                       "/home/nha/data/blender_glsl_material/render-osg/test/");
      
      osgDB::setDataFilePathList(pathList);
  }


  class CameraManipulator : public osgGA::TrackballManipulator
  {
  public:
      CameraManipulator()
      {
      }

      osg::Matrixd getMatrix() const
      {
          osg::Matrixd result;
          osg::Matrixd m = osg::Matrixd::translate( 0., 0., _distance ) *
            osg::Matrixd::rotate( _rotation ) *
            osg::Matrixd::translate( _center );
          result.orthoNormalize(m);
          return result;
      }
	
      osg::Matrixd getInverseMatrix() const
      {     
          osg::Matrixd result;
          osg::Matrixd m = osg::Matrixd::translate( -_center ) *
            osg::Matrixd::rotate( _rotation.inverse() ) *
            osg::Matrixd::translate( 0.0, 0.0, -_distance );

          result.orthoNormalize(m);
          return result;
      }

      void zoomModel(const float dy, bool pushForwardIfNeeded)
      {
          float scale = 1.0f + dy;
          _distance *= scale;
      }

  protected:
      ~CameraManipulator(){}
  };

  void Core::manipulator_init()
  {
      //viewer.run();
      manip = new CameraManipulator();

      double fovy;
      double aspectRatio;
      double zNear;
      double zFar;
      //cam->setViewMatrix(light_m);

      manip->setHomePosition(osg::Vec3(9,16,20),
                             osg::Vec3(9,16,0),
                             osg::Vec3(0,0,-1), false);

      viewer->setCameraManipulator(manip);
  }

  void Core::camera_init()
  {
      viewer->getCamera()->setProjectionResizePolicy(osg::Camera::FIXED);
      viewer->setLightingMode( osg::View::NO_LIGHT );

      viewer->getCamera()->setComputeNearFarMode(
                                    osg::CullSettings::DO_NOT_COMPUTE_NEAR_FAR);

      viewer->getCamera()->setClearMask( GL_COLOR_BUFFER_BIT
                                        |GL_DEPTH_BUFFER_BIT);

      osg::Matrix m = osg::Matrix(1, 0, 0, 0,
                                  0, 1, 0, 0,
                                  0, 0, 1, 0,
                                  -9, -16, -20, 1);

      viewer->getCamera()->setViewMatrix(m);
      viewer->getCamera()->setProjectionMatrixAsPerspective(123.673,
                                                            1.5,
                                                            0.1,
                                                            1000.0);

      viewer->getCamera()->setReferenceFrame(
                                    osg::Camera::ABSOLUTE_RF_INHERIT_VIEWPOINT);
  //    viewer->getCamera()->setReferenceFrame(osg::Camera::ABSOLUTE_RF);

  }


  //osg::ref_ptr<osg::Group>
  osg::Group *
  test_scene()
  {
    /*
      osg::ref_ptr<osg::Group> scene   = new osg::Group;

      osg::ref_ptr<osg::Group> cessna1 = (osg::Group*) 
                                              osgDB::readNodeFile("cessna.osg");
      osg::ref_ptr<osg::Group> cessna2 = (osg::Group*) 
                                              osgDB::readNodeFile("cessna.osg");
      osg::ref_ptr<osg::MatrixTransform> positioned = new osg::MatrixTransform;

      cessna1->getChild(0)->setNodeMask(CastsShadowTraversalMask | 
                                        ReceivesShadowTraversalMask);
      cessna2->getChild(0)->setNodeMask(CastsShadowTraversalMask |
                                        ReceivesShadowTraversalMask);

      positioned->setMatrix(osg::Matrix::translate(10,10,25));
      positioned->addChild(cessna1);
      scene->addChild(positioned);
      scene->addChild(cessna2); 
      return scene;
    */
      return new osg::Group;
  }



  void material_update_camera(osg::Camera *camera)
  {
      osg::Matrix *view = new osg::Matrix;
      osg::Matrix *view_inv = new osg::Matrix;

      view->orthoNormalize(sync_matrix(camera->getViewMatrix()));
      view_inv->orthoNormalize(sync_matrix(camera->getInverseViewMatrix()));
      // view_inv->invert(*view);  // Warning: dont double transpose on accident

      ss_set_m44_t(_scheme, "<world=>camera>", view);
      ss_set_m44_t(_scheme, "<camera=>world>", view_inv);
  }



  void set_animation(osg::ref_ptr<osg::Node> obj)
  {
      @c:define[(name-equal? str x result)]{
          @|result| = @|x|->getName() == "@|str|";
      }

      @c:define[(find-animation-manager state x)]{

          if (@|state|.valid())
              return;

          if (@|x|.getUpdateCallback()) 
          {
              osgAnimation::AnimationManagerBase* b = dynamic_cast
                  <osgAnimation::AnimationManagerBase*>
                  (@|x|.getUpdateCallback());
          
              if (b){
                  @|state| = new osgAnimation::BasicAnimationManager(*b);
                  return;
              }
          }
      }

      /////////////////

      osg::ref_ptr<osgAnimation::BasicAnimationManager> manager = NULL;

      @(node:fold "osg::ref_ptr<osgAnimation::BasicAnimationManager>" 
        "manager" "obj" find-animation-manager)


      if (manager.valid())
      {
          obj->setUpdateCallback(manager);

          @(c:for-each "osgAnimation::AnimationList" 
            "manager->getAnimationList()"
            @c:λ[(x)]{
                    std::cout << "animation: " 
                              << @|x|->getName()
                              << std::endl;
                })

          osg::ref_ptr<osgAnimation::Animation> animation;

          @(c:find "osgAnimation::AnimationList" 
            "animation"
            (curry name-equal? "Action")
            "manager->getAnimationList()")

          if (animation)
          {
              manager->playAnimation(animation);
          }

      } else 
      {
          osg::notify(osg::WARN) << 
              "no osgAnimation::AnimationManagerBase found in the subgraph,"
              "no animations available" << std::endl;
      }
  }


  void Core::mainloop()
  {    
  //    osg::ref_ptr<osg::Group> scene = test_scene();
  //    printf("ref:%d\n",scene->referenceCount());
      //abort();

      osg::ref_ptr<BlenderMaterial> material = new 
        BlenderMaterial("test/material");

      
      osg::ref_ptr<BlenderObject> BLEND_OBJ = new 
        BlenderObject(material, osgDB::readNodeFile("mattest.fbx"));

      set_animation(BLEND_OBJ);
      
        ///////////////////////
      osg::ref_ptr<osg::Group> blender = blenderRenderState();   
      osg::ref_ptr<ShadowGroup> sg     = new ShadowGroup(material);
      PreloadEnv p_env = {sg};

      material->preload_samplers(&p_env);
      material->addChild(BLEND_OBJ);

      blender->addChild(material);
      blender->addChild(sg);
      blender->addChild(createAxis());

      @(node:for-each "blender"
        @c:λ[(x)]{

            osg::NodePathList paths = @|x|.getParentalNodePaths();
            osg::NodePath path = paths[0];

            @(c:for-each "osg::NodePath" "path"
                @c:λ[(p)]{
                  const std::string& name = @|p|->getName();
                  osg::notify(osg::WARN) 
                    << "/"
                    << static_cast<void*>(@|p|)
                    << ":"
                    << (name.empty() ? "???" : name);
                })
            

            osg::notify(osg::WARN) 
              << std::endl;
          })

      osg::notify(osg::WARN) 
        << "root: "
        << static_cast<void*>(viewer)
        << std::endl;

      viewer->setSceneData(blender);
      viewer->stopThreading();


      // root->setCullingActive(false);  // TODO: remove this

      //viewer->setSceneData(scene); //compose3(sg,blender,scene));//compose3(sg, blender, scene));

      viewer->realize(); 

      while( !viewer->done() )
      {    
          viewer->advance();
          viewer->eventTraversal();
          viewer->updateTraversal();
          material_update_camera(viewer->getCamera());
          //extern void applyLampCamera(const char *id, osg::Camera *shadow);
          //applyLampCamera("lamp-0", viewer->getCamera());
          viewer->renderingTraversals();
      }

  }  


  scheme _scheme;

  int main( int argc, char **argv )
  {
      _scheme = ss_init();
      ss_import_linear_algebra(_scheme, NULL);
      ss_import_uniform(_scheme, NULL);
      ss_eval(_scheme, "(apply varlet (curlet) linear-algebra)");
      ss_eval(_scheme, "(apply varlet (curlet) uniform)");
      ss_load(_scheme, "../shader-link/shader-link.scm"); // TODO: error check
      ss_eval(_scheme, "(unit-test:shader-link)");

      Core *core = new Core;
      core->db_init();
      core->manipulator_init();
      core->camera_init();
      core->mainloop();

      ss_free(_scheme);
  }


 }) 
