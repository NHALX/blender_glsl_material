#lang at-exp s-exp "../../misc/c-pre.rkt"

(export
 (begin (import "Shadow"))
 @begin/text{
  @Shadow:header-source
  //////////////////////////////////////////////////
  // ╻ ╻
  // ┣━┫
  // ╹ ╹
  ///////// auto-generated by: @|__FILE__| /////////
  extern scheme _scheme;
  extern bool loadShaderSource(osg::Shader* obj, const std::string& fileName );

  struct PreloadEnv
  {
      ShadowGroup *sg;
  };

  class BlenderMaterial : public osg::Group //, public osg::NodeCallback
  {
  protected:
      ~BlenderMaterial()
      {
          
          // TODO: free other stuff
      }
	
      osg::ref_ptr<osg::Program> _program;
      osg::ref_ptr<osg::Shader>  _vert;
      osg::ref_ptr<osg::Shader>  _frag;
	
  public:
      BlenderMaterial(std::string file_name);
	
      void         bind_uniforms(osgUtil::CullVisitor* cv);
      virtual void traverse(osg::NodeVisitor &nv);
	
      osg::ref_ptr<osg::Program> getProgram()
      {
          return _program;
      }

      void preload_samplers(PreloadEnv *);
  };

  namespace material {
    std::map<std::string, BlenderMaterial*> 
      directory_load_all(std::string root);

    std::multimap<std::string, osg::Node *> 
      group_meshes(std::string root, osg::Group *node);
  }
})


(source
  (begin
   (import "Matrix")
   (import* ".."))
        
  @begin/text{
  
  //////////////////////////////////////////////////
  // ┏━╸
  // ┃    
  // ┗━╸
  ///////// auto-generated by: @|__FILE__| /////////

  #include "OpenSceneGraph.hh"
  @Matrix:header-source
  #include "generated/scheme.h"
  @..:header-source
  #include "Traversal.hh"
  #include <stdexcept>


  static 
  osg::Material* find_material(osg::Geode *geode)
  {
      @(c:guard "return NULL" 
        !NULL : osg::Drawable* drawable = "geode->getDrawable(0)"
        !NULL : osg::Geometry* geom     = "drawable->asGeometry()"
        !NULL : osg::StateSet* ss       = "geom->getStateSet()"
        !NULL : osg::Material* attr     =
                             "ss->getAttribute(osg::StateAttribute::MATERIAL)")
              
      return attr;
  }


  // NOTE: this relies strictly on the layout of the input scene graph
  std::multimap<std::string, osg::Node *> 
  material::group_meshes(std::string root, osg::Group *node)
  {        
      std::multimap<std::string, osg::Node *> output;
      
      for (int i = 0; i < node->getNumChildren(); ++i)
      {
          @(c:guard "continue"
            !NULL : osg::Group*    child    = "node->getChild(i)->asGroup()"
            !NULL : osg::Geode*    geode    = "child->getChild(0)->asGeode()"
            !NULL : osg::Material* material = "find_material(geode)")

          std::string name = material->getName();
          std::cout << name << "\n";

          output.insert(std::pair<std::string, osg::Node *>
                        (root + name, child));
      }

      return output;
  }


  std::map<std::string, BlenderMaterial*>
  material::directory_load_all(std::string root)
  {
      @(c:var "osgDB::DirectoryContents" 
         files = @S{osgDB::expandWildcardsInFilename(root + "*.scm")})

      @(c:map (c:dictionary "std::string" "BlenderMaterial*" "materials")
         files
         @c:λ[(x return)]{

            std::string name = @|x|.substr(0, @|x|.length() - 4);
            osg::notify(osg::WARN) 
              << "loading material: "
              << name
              << std::endl;

            @|return| = std::pair<std::string, BlenderMaterial*>
                (name, new BlenderMaterial(name));
        })

      return materials;
  }


  BlenderMaterial::BlenderMaterial(std::string filebase)
  {
      setName(filebase);

      _program = new osg::Program;
      _vert    = new osg::Shader(osg::Shader::VERTEX);
      _frag    = new osg::Shader(osg::Shader::FRAGMENT);

      if (!loadShaderSource(_vert, filebase + ".vert"))
          std::runtime_error("BlenderMaterial.LoadFile: Vertex Shader");

      if (!loadShaderSource(_frag, filebase + ".frag"))
          std::runtime_error("BlenderMaterial.LoadFile: Fragment Shader");

      ss_env_new(_scheme, filebase.c_str());
      ss_load(_scheme, (filebase + ".scm").c_str(), 
                        filebase.c_str()); // TODO: error check

      _program->addShader(_frag);
      _program->addShader(_vert);

      getOrCreateStateSet()->setAttributeAndModes(_program,
                                                  osg::StateAttribute::ON);
  }


  void
  BlenderMaterial::traverse(osg::NodeVisitor &nv)
  {
      osgUtil::CullVisitor* cv = dynamic_cast<osgUtil::CullVisitor*>(&nv);

      if (cv) // && cv->getTraversalMask() == -1) // TODO: whats the correct mask?
          bind_uniforms(cv);

      osg::Group::traverse(nv); 
  }


  void
  BlenderMaterial::preload_samplers(PreloadEnv *sg)
  {
      ss_env env = ss_env_enter(_scheme, getName().c_str());
      ss_call1p(_scheme, "preload", sg);
      ss_env_exit(_scheme, env);
  }


  void
  BlenderMaterial::bind_uniforms(osgUtil::CullVisitor* cv)
  {        
  #ifdef UNIFORM_INPUT_MATRIX
      const osg::Matrix& projection = *(cv->getProjectionMatrix());
      osg::Matrix projection_inv;
      projection_inv.invert(projection);

      set_m("my_ProjectionMatrix", projection);
      set_m("my_ProjectionMatrixInverse", projection_inv);
  #endif       
      ss_env env = ss_env_enter(_scheme, getName().c_str());
      ss_call1p(_scheme, "bind-samplers", this->getStateSet());
      ss_call1p(_scheme, "bind-uniforms-all", this->getStateSet());
      ss_env_exit(_scheme, env);

  }
 
 })
