#lang at-exp s-exp "../../misc/c-pre.rkt"

(export
 (begin (import "Shadow"))
 @begin/text{
  @Shadow:header-source
  //////////////////////////////////////////////////
  // ╻ ╻
  // ┣━┫
  // ╹ ╹
  ///////// auto-generated by: @|__FILE__| /////////
  extern scheme _scheme;
  extern bool loadShaderSource(osg::Shader* obj, const std::string& fileName );

  struct PreloadEnv
  {
      ShadowGroup *sg;
  };

  class BlenderMaterial : public osg::Group //, public osg::NodeCallback
  {
  protected:
      ~BlenderMaterial()
      {
          
          // TODO: free other stuff
      }
	
      osg::ref_ptr<osg::Program> _program;
      osg::ref_ptr<osg::Shader>  _vert;
      osg::ref_ptr<osg::Shader>  _frag;
	
  public:
      BlenderMaterial(const char *file_name);
	
      void         bind_uniforms(osgUtil::CullVisitor* cv);
      virtual void traverse(osg::NodeVisitor &nv);
	
      osg::ref_ptr<osg::Program> getProgram()
      {
          return _program;
      }

      void preload_samplers(PreloadEnv *);
  };

})


(source
  (begin
   (import "Matrix")
   (import* ".."))
        
  @begin/text{
  
  //////////////////////////////////////////////////
  // ┏━╸
  // ┃    
  // ┗━╸
  ///////// auto-generated by: @|__FILE__| /////////

  #include "OpenSceneGraph.hh"
  @Matrix:header-source
  #include "generated/scheme.h"
  @..:header-source
  #include "Traversal.hh"
  #include <stdexcept>


  BlenderMaterial::BlenderMaterial(const char *filebase)
  {
      setName("BlenderMaterial");
      #define SUFFIX_LEN     6
      #define SUFFIX_VERT    ".vert"
      #define SUFFIX_FRAG    ".frag"
      #define SUFFIX_UNIFORM ".scm\0"

      size_t len = SUFFIX_LEN + strlen(filebase);
      char buf[len];
      memcpy(buf, filebase, len - SUFFIX_LEN);

      _program = new osg::Program;
      _vert    = new osg::Shader(osg::Shader::VERTEX);
      _frag    = new osg::Shader(osg::Shader::FRAGMENT);

      memcpy(&buf[len - SUFFIX_LEN], SUFFIX_VERT, SUFFIX_LEN);
      if (!loadShaderSource(_vert, buf))
          std::runtime_error("BlenderMaterial.LoadFile: Vertex Shader");

      memcpy(&buf[len - SUFFIX_LEN], SUFFIX_FRAG, SUFFIX_LEN);
      if (!loadShaderSource(_frag, buf))
          std::runtime_error("BlenderMaterial.LoadFile: Fragment Shader");

      memcpy(&buf[len - SUFFIX_LEN], SUFFIX_UNIFORM, SUFFIX_LEN);
      ss_load(_scheme, buf); // TODO: error check

      _program->addShader(_frag);
      _program->addShader(_vert);

      getOrCreateStateSet()->setAttributeAndModes(_program,
                                                  osg::StateAttribute::ON);
  }


  void
  BlenderMaterial::traverse(osg::NodeVisitor &nv)
  {
      osgUtil::CullVisitor* cv = dynamic_cast<osgUtil::CullVisitor*>(&nv);

      if (cv) // && cv->getTraversalMask() == -1) // TODO: whats the correct mask?
          bind_uniforms(cv);

      osg::Group::traverse(nv); 
  }


  void
  BlenderMaterial::preload_samplers(PreloadEnv *sg)
  {
      ss_call1p(_scheme, "preload", sg);
  }


  void
  BlenderMaterial::bind_uniforms(osgUtil::CullVisitor* cv)
  {        
  #ifdef UNIFORM_INPUT_MATRIX
      const osg::Matrix& projection = *(cv->getProjectionMatrix());
      osg::Matrix projection_inv;
      projection_inv.invert(projection);

      set_m("my_ProjectionMatrix", projection);
      set_m("my_ProjectionMatrixInverse", projection_inv);
  #endif       


      ss_call1p(_scheme, "bind-samplers", this->getStateSet());
      ss_call1p(_scheme, "bind-uniforms", this->getStateSet());
  }
 
 })
